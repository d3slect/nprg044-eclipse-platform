#summary Eclipse Perspectives, Wizards

= Introduction =
<wiki:toc max_depth="3" />

= Perspective =
To setup a new perspective it is necessary to define the extension `org.eclipse.ui.perspectives` and provide an implementation of the `IPerspectiveFactory` interface. 
The implementation creates the initial layout of the perspective (views, editor areas, menus) via `IPageLayout`.
{{{
public class TwitterPerspectiveFactory implements IPerspectiveFactory {
	
	/** The ID of this GUI element. */
	public static final String PERSPECTIVE_ID = "cz.cuni.mff.d3s.nprg044.twitter.ui.perspective.TwitterPerspective";

	@Override
	public void createInitialLayout(IPageLayout layout) {
		// define layout of the perspective
		addViews(layout);
		addActionSets(layout);
		addNewWizardShortcuts(layout);
		addPerspectiveShortcuts(layout);
		addViewShortcuts(layout);
	}

	private void addViews(IPageLayout layout) {
		// create the left panel view area programmatically
		// its position is left with respect to editor area
		// left panel will occupy 25% of the horizontal space originally given to the editor area
		IFolderLayout left = layout.createFolder("left", IPageLayout.LEFT, 0.25f, layout.getEditorArea());
		
		// left panel contains the message timeline and properties view/sheet
		left.addView(TwitterMessageTimelineView.ID);
		left.addView(IPageLayout.ID_PROP_SHEET);
		
		// create the bottom panel view area
		// bottom panel will occupy 25% of the vertical space originally given to the editor area
		IFolderLayout bottom = layout.createFolder("bottom", IPageLayout.BOTTOM, 0.75f, layout.getEditorArea());
		bottom.addView(IPageLayout.ID_PROP_SHEET);
		bottom.addView(IPageLayout.ID_PROBLEM_VIEW);
		bottom.addView("org.eclipse.pde.runtime.LogView");
		
		// create the right panel view area
		// right panel will occupy 25% of the horizontal space originally given to the editor area
		IFolderLayout right = layout.createFolder("right", IPageLayout.RIGHT, 0.75f, layout.getEditorArea());
		right.addView(IPageLayout.ID_OUTLINE);
	}

	private void addActionSets(IPageLayout layout) {
	}	

	private void addPerspectiveShortcuts(IPageLayout layout) {
		// add button that will turn of this perspective into the top right corner
		layout.addPerspectiveShortcut(PERSPECTIVE_ID);
	}

	// wizards like those in "File -> New"
	private void addNewWizardShortcuts(IPageLayout layout) {
		//layout.addNewWizardShortcut(LoginWizard.ID);
	}

	// shortcuts like those in "Window -> Show View"
	private void addViewShortcuts(IPageLayout layout) {
	}
}
}}}


== Perspective extension ==
It is possible to modify existing perspectives via the extension point `org.eclipse.ui.perspectiveExtensions`
 * define _targetID_ 
   * regexp or ID of the target perspective (e.g,. `cz.cuni.mff.d3s.nprg044.twitter.ui.perspective.TwitterPerspective`)
 * define target perspective modification:
   * add new wizard shortcuts
   * add perspective shortcuts
   * add view shortcuts
   * hide items

||_To reflect the changes it is often necessary to reset the perspective._||


= Wizards =
A wizard is a dialog implementing the `IWizard` interface. It can be defined via extensions `org.eclipse.ui.newWizards`, `org.eclipse.ui.importWizards` or `org.eclipse.ui.exportWizards`, or implemented ad-hoc.

 * create the wizard for a new message
   * define the extension `org.eclipse.ui.newWizards` 
   * add a new category `Twitter` (it will be shown in the dialog for wizard selection)
   * define _name_, 
   * define _finalPerspective_ as _Twitter perspective_
   * implement the _class_ attribute
     * the wizard has to implement the `IWizard` interface; however, it is beneficial to extend the `Wizard` class
{{{
public class NewMessageWizard extends Wizard implements INewWizard {
	
	private MessageWizardPage messagePage;

	public NewMessageWizard() {
		setWindowTitle("Post a new message");
		setNeedsProgressMonitor(true);
	}

	@Override
	public void init(IWorkbench workbench, IStructuredSelection selection) {
	}
	
	// create our wizard page in a lazy manner
	@Override
	public void addPages() {
		messagePage = new MessageWizardPage("Message");
		addPage(messagePage);
	}

	// perform response to the user clicking on the "Finish" button
	@Override
	public boolean performFinish() {
		if (messagePage.canFlipToNextPage()) {
			System.out.println("Message posted: " + messagePage.getMessageText());			
			return true;
		} 
		else {
			return false;
		}
	}
}
}}}
   * the wizard has to setup pages in the method `addPages` and perform the finish action in the method `performFinish` 

The wizard page represents one page shown in the wizard. It has to setup its layout and validation of the user input. The wizard page is represented by the interface `IWizardPage`, but it is better to extend the class `WizardPage`.
{{{
public class MessageWizardPage extends WizardPage {

	public static final int MAX_CHAR = 150;
	
	private TextViewer messageEditor;
	private Label characterCount;

	protected MessageWizardPage(String pageName) {
		super(pageName);
		
		setTitle("Post a new message");
		
		setDescription("Post twitter message. It should not contain more than 150 characters!");
		
		setPageComplete(false);
	}

	// create layout of the wizard page
	@Override
	public void createControl(Composite parent) {
		final Composite composite = new Composite(parent, SWT.NONE);
		GridLayout layout = new GridLayout(1, false);
		composite.setLayout(layout);
		setControl(composite);
		
		messageEditor = new TextViewer(composite, SWT.BORDER | SWT.MULTI);
		messageEditor.getControl().setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));		
		messageEditor.getTextWidget().addModifyListener(new ModifyListener() {
			// check the number of characters after each modification
			@Override
			public void modifyText(ModifyEvent e) {
				updateCharactersCount(messageEditor.getTextWidget().getText().length());				
			}
		});
		
		characterCount = new Label(composite, SWT.NONE);
		characterCount.setText(MAX_CHAR + " characters");				
		characterCount.setLayoutData(new GridData(SWT.RIGHT, SWT.BEGINNING, false, false));		
	}

	protected void updateCharactersCount(int length) {		
		characterCount.setText((MAX_CHAR-length) + " characters");
		
		if (validatePage()) {
			setPageComplete(true);				
		} 
		else {
			setPageComplete(false);
		}
	}
	
	// validates the user input
	protected boolean validatePage() {
		int length = messageEditor.getTextWidget().getText() != null ? messageEditor.getTextWidget().getText().length() : 0;
	
		if (length > 0 && length <= MAX_CHAR) {
			setErrorMessage(null);
			return true;
		} 
		else {
			setErrorMessage("Character count has to be in range (0..150>" );
			return false;
		}
	}
	
	// returns true if this page is complete and we can move to the next one
	@Override
	public boolean canFlipToNextPage() {		
		return validatePage();
	}

	public String getMessageText() {		
		return messageEditor.getDocument().get();
	}
}
}}}

||Note: _To launch the wizard programmatically, it is necessary to create an instance of the wizard and pass it to the instance of the `WizardDialog` class, which is responsible for presentation of the wizard._||

= Jobs =
The `Job` class allows execution of user code in a separate thread.

`Job` includes the following methods:
 * `run()` - user has to override the method to implement the logic of a given job
 * `schedule()` - schedule the job
 * `join()` - wait for the job to finish
 * `cancel()` - cancel the job, only setup the flag published via the method `isCanceled()`

{{{
if (!job.cancel())
      job.join();
}}}

Job result signaled via `IStatus` (`IStatus.OK`, `IStatus.ERROR`)

Job types:
  * user - modal dialog is shown, can be put into the background. Configured via the call `setUser(true)`.
  * system - no contribution into the UI. E.g., jobs which are NOT initiated by a user. Configured via the call `setSystem(true)` before job scheduling.

== Periodic jobs == 
The job implementation has to reschedule itself - i.e., it needs to call `schedule(num)`.

== Reporting progress ==
Progress monitor is represented by the `IProgressMonitor` interface:
  * `monitor.beginTask("Getting follows", numberOfFollows);` - start a monitor for given units of work
  * `monitor.worked(1)` - one unit of work processed
  * `monitor.done()` - computation is finished

= Resources =
  * Eclipse Help - Wizards - http://help.eclipse.org/juno/topic/org.eclipse.platform.doc.isv/guide/dialogs.htm
  * Eclipse Help - Perspective - http://help.eclipse.org/juno/topic/org.eclipse.platform.doc.isv/guide/workbench_perspectives.htm
  * Eclipse Article - JFace Wizards - http://www.eclipse.org/articles/article.php?file=Article-JFaceWizards/index.html
  * Eclipse Atticle - On the Job: The Eclipse Jobs API - http://www.eclipse.org/articles/Article-Concurrency/jobs-api.html
  
