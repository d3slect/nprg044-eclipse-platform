#summary UI Basics and Views

=Eclipse UI basics=
<wiki:toc max_depth="2" />

= SWT and JFace =
== SWT ==
SWT is a widget toolkit providing API built on top of native OS GUI platform. It is part of Eclipse platform, but you can use it in standalone applications. It is event driven. The events are handled by UI thread (the thread which creates `Display` object).

You never know if you are running in UI or non-UI thread. Hence, applications that wish to call UI code from a non-UI thread must provide a Runnable that calls the UI code. The methods syncExec(Runnable) and asyncExec(Runnable) in the Display class are used to execute these runnables in the UI thread during the event loop. See http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/guide/swt_threading.htm. 

  * Class `Display` - The `Display` represents the connection between SWT and the underlying platform's GUI system. Displays are primarily used to manage the platform event loop and control communication between the UI thread and other threads. You must create a display before creating any windows, and you must dispose of the display when your shell is closed. This is typically done by Eclipse workbench. 

  * Class `Shell` is a _window_ managed by the OS platform window manager. Top level shells are those that are created as a child of the display. These windows are the windows that users move, resize, minimize, and maximize while using the application. Secondary shells are those that are created as a child of another shell. These windows are typically used as dialog windows or other transient windows that only exist in the context of another window (so called _composite widgets_).

 * Class `SWT` - contains definition of style bits. E.g., SWT.YES, SWT.NO, SWT.VERTICAL, SWT.BORDER. Intepretation depends on control (e.g., SWT.SINGLE - single selection, single line)

Typical structure of standalone SWT application implementation:
{{{
  public static void main (String [] args) {
      Display display = new Display();
      Shell shell = new Shell(display);
      Label label = new Label(shell, SWT.CENTER);
      label.setText("Hello_world");
      label.setBounds(shell.getClientArea ());
      shell.open();
      while (!shell.isDisposed()) {
         if (!display.readAndDispatch()) display.sleep();
      }
      display.dispose();
   }
}}}

 * Class `Widget` represents a handle of OS resource. Needs to be disposed explicitely!

||Note: _SWT requires that the user has to explicitelly free any OS resources which were allocated. In SWT, `Widget.dispose()` method is used for freeying resources associated with a widget.||

There are several simple rules for disposing widgets:
  * if the user creates a widget using constructor, it has to also dispose it.
  * When `Composite` widget is diposed, also its children are recursively disposed.
  * If the user gets a widget without using ctor, he/she cannot dispose it.
  * If the user passes a reference of widget, he/she cannot dispose it until the widget is still in use._ ||


There are three basic types of widgets - _Control, Layout, Event_.
=== SWT Controls ===
Package `org.eclipse.swt.widgets` provides Label, Tree, Table, Text, List, Button, Canvas - see [http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/swt.htm Eclipse Help SWT] for the full list.
You can fully control these widgets - configure fonts, colors, dimension.

===SWT Layouts ===
Package `org.eclipse.swt.layout` provides:
  * `FillLayout` 
   * Lays out controls in a single row or column, forcing them to be the same size.
  * `FormLayout` 
   *Positions the children by using FormAttachments to optionally configure the left, top, right and bottom edges of each child.
  * `GridLayout`
   * Positions the children by rows and columns.
  * `RowLayout`
    * Places the children either in horizontal rows or vertical columns.


=== SWT Events ===
SWT is event driven. Package `org.eclipse.swt.events` provides various kinds of events - modify, verify, key, move, drag (see http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/swt.htm). 
The `Control` class has methods to register listeners for various kinds of events.

===SWT graphics===
Class `GC` (graphical context) to draw customized widgets. See http://help.eclipse.org/helios/topic/org.eclipse.platform.doc.isv/guide/swt_graphics.htm

=== Example of SWT ===

 * create a new plug-in project `swt.examples`
  * this is little bit tricky, however, we do need to care about dependencies due to classpath is automatically resolved.
 * add `org.eclipse.ui` plug-in into dependencies
 * create a new class `swt.examples.Example01` with a main method 
{{{
// based on SWT code snippets http://www.eclipse.org/swt/snippets/
public class Example01 {
	
	public static void main(String[] args) {
		// create display
		Display display = new Display();
		// top-level widget is shell
		final Shell shell = new Shell(display);

		// create a GridLayout
		shell.setLayout(new GridLayout());
		final Composite c = new Composite(shell, SWT.NONE);
		GridLayout layout = new GridLayout(3, true);
		c.setLayout(layout);

		for (int i = 0; i < 5; i++) {
			Button b = new Button(c, SWT.PUSH | SWT.FLAT);
			b.setText("Button " + i);
		}

		Button b = new Button(shell, SWT.PUSH);
		b.setText("add a new button at row 2 column 1");
		final int[] index = new int[1];
		b.addListener(SWT.Selection, new Listener() {
			public void handleEvent(Event e) {
				Button s = new Button(c, SWT.PUSH);
				s.setText("Special " + index[0]);
				index[0]++;
				Control[] children = c.getChildren();
				s.moveAbove(children[3]);
				shell.layout(new Control[] { s });
			}
		});

		shell.open();
		shell.pack();
		// main event loop
		while (!shell.isDisposed()) {
			if (!display.readAndDispatch())
				display.sleep();
		}
		// dispose widgets
		display.dispose();
	}
} 
}}}
 * run the class `swt.examples.Example01` as _Java Application_ !

  ||_Note: for more SWT code snippets please visit http://www.eclipse.org/swt/snippets/._||
== JFace ==
Packages `org.eclipse.jface.*` provides implementation of JFace UI toolkit on top of SWT toolkit. The purpose is just to simplify implementation of UI. It handles:
  * viewers
  * actions
  * images and fonts registeries
  * dialogs and wizards

Notes:   
  * Method `getControl()` of JFace widgets serves to get associated SWT control.
  * JFace also provides a way how to automatically bind widget with data.

===Viewers===
JFace widget which display a structured data - list, tree, tables (encapsulates native SWT widgets) - `ListViewer`, `TreeViewer` and `TableViewer`. It further allows data sorting, filtering, selection and visualization.

The basic concepts for viewers are:
  * _input element_  - the main object that the viewer is displaying (editing). It can be anything (table, JSON object, file, URI).
  * _content provider_ - returns data which will be shown by viewer. The provider takes the input element and returns an array of data. See interface `IContentProvider` or `IStructuredContentProvider` which is used to obtain structured data. They can be also lazy in case when the viewer specifies SWT.VIRTUAL flag. Then content provider has to implement `ILazyContentProvider` which produces data on demand.
  * _label provider_ - defines how the data returned by content provider are shown (image, text in colors). See interface `ILabelProvider`.
    * if the label provider also implements a dedicated interface (e.g., `IColorProvider`,`IFontProvider`, `ILabelDecorator`) it can be handled by the viewer in its specific way.

The shared implementation is provided by `ContentViewer` class:
  * method `void setInput(Object o)`
  * method `void setContentProvider(IContentProvider contentProvider)`
  * method `void setLabelProvider(IBaseLabelProvider labelProvider)` 

  ||Note: _Instances of particular content and label providers are not intended to be shared across multiple viewers. Even if all your viewers use the same type of content or label provider, each viewer should be initialized with its own instance of the provider class. The provider life cycle protocol is designed for a 1-to-1 relationship between a provider and its viewer._||
   
= Workbench UI =
Eclipse workbench provides a GUI model which is not connected to JFace. It provides workbench parts represented by _views_, and _editors_.
{{{
IAdaptable
 |- IWorkbenchPart
   |- IViewPart 
   |- IEditorPart
}}}

The class `IWorkbenchPart`:
 * method `void createPartControl(Composite parent)`
 * method `IWorkbenchPartSite getSite()` - _site_ is a primary interface between a workbench part and the workbench. For example, it is used for registering menus or global actions.
 * method `String getTitle()`
 * method `Image getTitleImage()`
 * method `void setFocus()` - Asks this part to take focus within the workbench. Parts must assign focus to one of the controls contained in the part's parent composite. It is called by workbench

  ||Note:_There are also interfaces `IWorkbenchPart2` and `IWorkbenchPart3`. They represent new version of `IWorkbenchPart`. This is common concept of introducing new version of interfaces in Eclipse_||

The class `IViewPart`:
 * `void init(IViewSite site)` - Initializes this view with the given view site. It is called by the workbench automatically during initialization of the part.

The class `IEditorPart`:
 * `void init(IEditorSite site, IEditorInput input)` - Initializes this editor with the given editor site and editor input (e.g., file, URI).It is automatically called by workbench.

== Views ==
A view is class implementing `IViewPart` interface. It shows a data with help of some [Tutorial03ViewsEditors#Viewers viewer]. It is beneficial to start with extending existing `ViewPart` class implementing basic infrastructure. 
 
Important points:
 * method `createControlPart()` - create a graphical viewer showed by a view. For example, table, tree, or hand-made graph visualizator. Any SWT code can be here.
   * calling method `viewer.setInput()` - setup viewer input 
   * calling method `viewer.setContentProvider()`
   * calling method `viewer.setLabelProvider()` 
   * registering actions hooks/menus - e.g., via calling `getSite().registerContextMenu(menuMgr, viewer);`

=== Example: `cz.cuni.mff.d3s.twitter.ui.views`===
  || Note: _Plug-in name follows common Eclipse naming convention - plug-in contributes into UI by providing new views hence its name contains `ui.views` part._||

  Goal: _Create a plugin providing a view showing message timeline for a given Twitter user._

  * import into a workspace plug-in `cz.cuni.mff.d3s.twitter.api`
  * create a new plug-in `cz.cuni.mff.d3s.twitter.ui.views`
  * configure `plugin.xml`:
    * add a dependency on plug-in `cz.cuni.mff.d3s.twitter.api`
    * add dependencies on plug-ins `org.eclipse.ui` and `org.eclipse.core.runtime`
    * define extension points:
      * `org.eclipse.ui.views`:
        * add a new category _Twitter Category_ 
          * category will be shown in menu _Window > Show Views > Others..._
        * add a new view
          * define ID, name, category (to Twitter category), icon
            * fastViewWidthRatio = 0.3 (one third of workbench width)
            * allowMultiple = true (we will allow showing timelines of various users)
          * define `class` attribute to `cz.cuni.mff.d3s.twitter.ui.views.TwitterMessageTimelineView`    
    * implements the class (inherits from the `ViewPart` class)
      * method `createPartControl(Composite parent)
        * create `GridLayout`, pass it to `parent.setLayout()`
{{{
GridLayout layout = new GridLayout(1, true);
parent.setLayout(layout);		
}}}
        * create `Text` control `searchBox` with flags `SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH`
         * setup layout data - `new GridData(GridData.FILL_HORIZONTAL)`
{{{
searchBox = new Text(parent, SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH);
searchBox.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
searchBox.setText("vtipy");
}}}
        * create `TableViewer` control `viewer` with flags `SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER`
         * setup layout data `new GridData(GridData.FILL_BOTH)`
           * you have to call `viewer.getControl()` to access underlying SWT control (`TableViewer` is JFace widget)
{{{
viewer = new TableViewer(parent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
viewer.getControl().setLayoutData(new GridData(GridData.FILL_BOTH));	
}}}
         * setup input to `viewer.setInput(getViewSite())`	
      * if you need lazy content resolving then put `SWT.VIRTUAL` into `viewer`'s flags. But, the content provider has to implement `ILazyContentProvider` instead of `IStructureContentProvider`
    * try to run in debug mode without configuring content provider
{{{
public class TwitterMessageTimelineView extends ViewPart {
	private static final String[] COLUMN_NAMES = {"#", "username", "message"};
	private static final int[] COLUMN_WIDTHS = {30, 100, 200};
	private TableViewer viewer;
	private Text searchBox;

	/**
	 * 
	 */
	public TwitterMessageTimelineView() {	
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.part.WorkbenchPart#createPartControl(org.eclipse.swt.widgets.Composite)
	 */
	@Override
	public void createPartControl(Composite parent) {
		GridLayout layout = new GridLayout(1, true);
		parent.setLayout(layout);		
		searchBox = new Text(parent, SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH);
		searchBox.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
		searchBox.setText("vtipy");		
				
		viewer = new TableViewer(parent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
		createColumns(viewer);
		viewer.setContentProvider(new MessageTimelineContentProvider());
		viewer.setLabelProvider(new MessageTimelineLabelProvider());
		// the input for the content provider
		viewer.setInput(searchBox);		
		viewer.getControl().setLayoutData(new GridData(GridData.FILL_BOTH));

		// tuning of the underlying table		
		viewer.getTable().setLinesVisible(true);		
		viewer.getTable().setHeaderVisible(true);
		
		// make selection available to others
		getSite().setSelectionProvider(viewer);
	}
	
	private void createColumns(TableViewer tableViewer) {
		for (int i = 0; i < COLUMN_NAMES.length; i++) {
			TableViewerColumn tvColumn = new TableViewerColumn(tableViewer, SWT.NULL);
			TableColumn column = tvColumn.getColumn();
			column.setWidth(COLUMN_WIDTHS[i]);
			column.setText(COLUMN_NAMES[i]);
			// I can also here register separated cell providers via calling TableViewerColumn.setLabelProvider
			// - @see CellLabelProvider or StyledCellLabelProvider 			
		}		
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.part.WorkbenchPart#setFocus()
	 */
	@Override
	public void setFocus() {
		this.searchBox.setFocus();
	}

}
}}}	

    * implements content provider `MessageTimelineContentProvider` inheriting from `IStructureContentProvider`
       * implements `inputChange` method
         * register/deregister listeners to input, refreshing of the viewer is not necessary, because it is done by underlying infrastructure
{{{
public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
  this.viewer = viewer;

  if (oldInput == newInput) 
	  return;

  if (oldInput instanceof Control) {
	  Control c = (Control) oldInput;
	  if (!c.isDisposed()) {
		  ((Control) oldInput).removeKeyListener(keyListener);
	  }
  }
  if (newInput instanceof Control) {
	  Control c = (Control) newInput;
	  if (!c.isDisposed()) {
		  ((Control) newInput).addKeyListener(keyListener);
	  }
  }
}
}}}
       * add key listern `keyListener`
{{{
private KeyListener keyListener = new KeyAdapter() {
        private String username;

	public void keyReleased(KeyEvent e) {
		if (e.keyCode == SWT.CR || e.keyCode == SWT.KEYPAD_CR) {
			if (e.widget instanceof Text) {
				String newUsername = ((Text) e.widget).getText();
				if (!newUsername.equals(username)) {
					username = newUsername;
					// run in UI thread
					e.display.asyncExec(new Runnable() {							
						@Override
						public void run() {
							// IMPORTANT it is required to check if the widget is not disposed
							if (!viewer.getControl().isDisposed()) {
								viewer.refresh();
							}
						}
					});
				}
			}
		}
	};
};
}}}
       * implements `getElements` method
        * parameter `inputElement` is an input element setup by calling `setInput` method of the viewer
{{{
public Object[] getElements(Object inputElement) {		
	  String username = getUsername(inputElement);
	  if (username == null || "".equals(username)) {
		  return EMPTY_CONTENT;			
	  } 
	  Twitter twitter = new TwitterFactory().getInstance();
  try {
      List<Status> statuses = twitter.getUserTimeline(username);
      if (!statuses.isEmpty()) {
	  return statuses.toArray();
      } else {
	  return EMPTY_CONTENT;
      }
  } catch (Exception e) {
	  return new String[] {e.getMessage()};
  }
}

private String getUsername(Object inputElement) {
	if (inputElement instanceof Text) {
		return ((Text) inputElement).getText();
	} else if (inputElement instanceof UserNode) {
		return ((UserNode) inputElement).getUser().getScreenName();			
	}
	
	return null;
}
}}}
       * in method `createPartControl` of the class `TwitterMessageTimelineView` setup `viewer.setInput(searchBox)` 
         * searchBox will serves as an input for content provider
         * it can be changed. The change invokes the method `inputChanged` of the content provider.
       * Note: _try to setup content provider for `viewer` control during debugging the application_
    * try to run without LabelProvider
{{{
public class MessageTimelineContentProvider implements
		IStructuredContentProvider {
	
	private final static String[] EMPTY_CONTENT = new String[] {"There is no message to show..."}; 
	
	private Viewer viewer;
	
	private KeyListener keyListener = new KeyAdapter() {
		private String username;
		public void keyReleased(KeyEvent e) {
			if (e.keyCode == SWT.CR || e.keyCode == SWT.KEYPAD_CR) {
				if (e.widget instanceof Text) {
					String newUsername = ((Text) e.widget).getText();
					if (!newUsername.equals(username)) {
						username = newUsername;
						// run in UI thread
						e.display.asyncExec(new Runnable() {							
							@Override
							public void run() {
								viewer.refresh();								
							}
						});
					}
				}
			}
		};
	};

	@Override
	public void dispose() {	
	}

	@Override
	public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
		this.viewer = viewer;
		
		if (oldInput instanceof Control) {
			Control c = (Control) oldInput;
			if (!c.isDisposed()) {
				((Control) oldInput).removeKeyListener(keyListener);
			}
		}
		if (newInput instanceof Control) {
			Control c = (Control) newInput;
			if (!c.isDisposed()) {
				((Control) newInput).addKeyListener(keyListener);
			}
		}
	}

	@Override
	public Object[] getElements(Object inputElement) {		
		String username = getUsername(inputElement);
		if (username == null || "".equals(username)) {
			return EMPTY_CONTENT;			
		} 
		Twitter twitter = new TwitterFactory().getInstance();
		try {
		    List<Status> statuses = twitter.getUserTimeline(username);
		    if (!statuses.isEmpty()) {
			return statuses.toArray();
		    } else {
			return EMPTY_CONTENT;
		    }
		} catch (Exception e) {
			return new String[] {e.getMessage()};
		}
	}
	
	private String getUsername(Object inputElement) {
		if (inputElement instanceof Text) {
			return ((Text) inputElement).getText();
		} 
		
		return null;
	}
}
}}}
    * implements `MessageTimelineLabelProvider` extending the class `LabelProvider` (implementing `ILabelProvider`) and implementing `ITableLabelProvider`.
     * it is neccessary to return the right text/image for each column
       * there is also way via the method `TableViewerColumn.setLabelProvider()` to configure separated label provider for each column.
     * for images you can use built-in images accessible via call `PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_ELEMENT);`      
{{{
public class MessageTimelineLabelProvider extends LabelProvider implements ITableLabelProvider {

	@Override
	public Image getColumnImage(Object element, int columnIndex) {
		if (element instanceof Status && columnIndex == 0) {
			return getImage(element);
		}
		
		return null;
	}

	@Override
	public String getColumnText(Object element, int columnIndex) {
		if (element instanceof Status) {
			Status status = (Status) element;
			
			switch (columnIndex) {
			case 0:
				return null;
			case 1:				
				return '@' + status.getUser().getScreenName();
			case 2:
				return status.getText();
			default:
				return null;
			}			
		}	
		
		return null;
	}
	
	@Override
	public Image getImage(Object element) {		
		return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_ELEMENT);
	}
}
}}}
     

== Actions in Views ==
===Context and Expressions===
We want to add delete command which will clear the timeline view.

First we have to define the context when the delete command will be applied. For this purpose, expresions can be used. Each expression defines a condition which has to be satisfied. The expression can be re-used in other definitions.
  * open `plugin.xml`
    * add a new dependency `org.eclipse.core.expressions`
  * add a new extension `org.eclipse.core.expressions.definitions`
   * define ID `cz.cuni.mff.d3s.nprg044.twitter.ui.view.inTimelineView`
     * add `with` sub-element with value `activePartId` (for more variables see [http://wiki.eclipse.org/Command_Core_Expressions Core Expressions Help])
       * add `equals` sub-element with value `cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (it is ID of defined MessageTimelineView)

Add a new handler for global delete command (with id `org.eclipse.ui.edit.delete`) which will be active if and only if the timeline view is focused:
  * open `plugin.xml`
  * add a new extension `org.eclipse.ui.handlers`
    * add a new handler:  
     * setup _commandId_ to `org.eclipse.ui.edit.delete`
     * add a new sub-element `activeWhen`
       * add a new `reference` sub-element and setup it to `cz.cuni.mff.d3s.nprg044.twitter.ui.view.inTimelineView`
    * add handler implementation:
      * look at a helper class `HandlerUtil`
{{{
public class CleanTimelineView extends AbstractHandler{

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		IWorkbenchPart part = HandlerUtil.getActivePart(event);
		if (part instanceof TwitterMessageTimelineView) {
			((TwitterMessageTimelineView) part).cleanTimeline();
		}
		return null;
	}

}
}}}
  * add a new method `cleanTimeline` into the class `TwitterMessageTimelineView`:
{{{
public void cleanTimeline() {
	searchBox.setText("");
	viewer.refresh();
}
}}}
  * try to run the example and observe behavior of delete command
 
===Toolbar===
Let's put the delete command into a toolbar of `TwitterMessageTimelineView` view:
  * open `plugin.xml`
  * add the extension `org.eclipse.ui.menus`
   * add a new _menuContribution_ 
     * setup _locationURI_ to `toolbar:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (toolbar:<view ID>)
     * add a sub-element _command_ referring `org.eclipse.ui.edit.delete` command

===Pop-up menu===
 * as above, but _locatioURI_ is `menu:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (menu:<view ID>)

===Context menu===
The context menu has to be register first to allow contribution via extension point 'org.eclipse.ui.menus'. The view can have multiple context menu registered. Default ID of the context  menu is the part ID.

 * Add a new method `createContextMenu` into the class `TwitterMessageTimelineView`
   * The method is called from the method `createPartControl`
{{{
private void createContextMenu() {
    MenuManager menuManager = new MenuManager("#PopupMenu");
    menuManager.setRemoveAllWhenShown(true);
    menuManager.addMenuListener(new IMenuListener() {
	    
	    @Override
	    public void menuAboutToShow(IMenuManager manager) {
		    fillContextMenu(manager);				
	    }
    });
    Menu menu = menuManager.createContextMenu(viewer.getControl());
    viewer.getControl().setMenu(menu);
    getSite().registerContextMenu(menuManager, viewer);
}
}}}
 * add method `fillContextMenu`
   * it is necessary to add a separator for additions - it is the place where new actions will be placed.
{{{
private void fillContextMenu(IMenuManager manager) {
	// this is required to allow contribution into the context menu
	manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));				
}
}}}

 * add a _menuContribution_ like in cases above, but set _locationURI_ to `popup:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (for one context menu the locationURI has the form `popup:<view ID>`)
 
 * add a new _command_ definition `cz.cuni.mff.d3s.nprg044.twitter.ui.view.showMessageDetails` with default command handler which will show a _Property view_:
{{{
public class CleanTimelineView extends AbstractHandler{

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		IWorkbenchPart part = HandlerUtil.getActivePart(event);
		if (part instanceof TwitterMessageTimelineView) {
			((TwitterMessageTimelineView) part).cleanTimeline();
		}
		return null;
	}

}
}}}
  * add the command into context menu


== Property sheet ==
We want to select the message details in _Property View_. The message is represented by the object `Status`.

At first we have to provide a selection from the viewer. It is necessary to have the line 
{{{
getSite().setSelectionProvider(viewer);
}}} 
in the class `TwitterMessageTimelineView`.

Then we have to adapt `Status` to `IPropertySource` type which provides details about status (plugin `org.eclipse.ui.views` has to be in dependencies). There are two ways of adaptation:
  # the `Status` has to implement `IAdaptable` interface:
{{{
public Object getAdapter(Class adapter) {
  return IPropertySource.class.equals(adapter) ? return new StatusPropertySource(this) : null;
}
}}}
   * this is common solution if you can change the source code of `Status` class, however, in our case it is provided by third party library. But, there is another solution:
 # register an adapter factory for given type:
  * open `plugin.xml`
  * add a new extension `org.eclipse.core.runtime.adapters`
    * add a new factory:
      * _adaptableType_ = `twitter4j.Status` (what is adapted)
      * _class_ = `cz.cuni.mff.d3s.nprg044.twitter.ui.view.adapters.TwitterAdapterFactory` (adaptation factory)
      * add a new sub-element `adapter` (what is a target of adaptation)
        * _type_ = `org.eclipse.ui.views.properties.IPropertySource`

  * implements the factory `cz.cuni.mff.d3s.nprg044.twitter.ui.view.adapters.TwitterAdapterFactory`:
{{{
public class TwitterAdapterFactory implements IAdapterFactory {
	
	private static final Class[] SUPPORTED_ADAPTERS = { IPropertySource.class };

	@Override
	public Object getAdapter(Object adaptableObject, Class adapterType) {
		if  (IPropertySource.class.equals(adapterType)) {
			return new TwitterStatusPropertySource((Status) adaptableObject);
		}
		return null;
	}

	@Override
	public Class[] getAdapterList() {
		return SUPPORTED_ADAPTERS;
	}

}
}}}

   * and implement the class `TwitterStatusPropertySource`
{{{
public class TwitterStatusPropertySource implements IPropertySource {

	private static final String MSG_ID = "twitter.prop.msg";
	private static final String RETWEET_COUNT_ID = "twitter.prop.retweet.count";
	
	private Status status;	
	private IPropertyDescriptor[] propertyDescriptors;

	public TwitterStatusPropertySource(Status status) {
		this.status = status;
	}

	@Override
	public Object getEditableValue() {
		return null;
	}

	@Override
	public IPropertyDescriptor[] getPropertyDescriptors() {
		if (propertyDescriptors == null) {
			IPropertyDescriptor descMessage = new PropertyDescriptor(MSG_ID, "Message");
			IPropertyDescriptor retweetCount= new PropertyDescriptor(RETWEET_COUNT_ID, "Retweet count");
			propertyDescriptors = new IPropertyDescriptor[] { descMessage, retweetCount };
		}
		
		return propertyDescriptors;
	}

	@Override
	public Object getPropertyValue(Object id) {
		if (id.equals(MSG_ID)) {
			return status.getText();
		} else if (id.equals(RETWEET_COUNT_ID)) {
			return status.getRetweetCount();
		}
		
		return null;
	}

	@Override
	public boolean isPropertySet(Object id) {
		return false;
	}

	@Override
	public void resetPropertyValue(Object id) {
	}

	@Override
	public void setPropertyValue(Object id, Object value) {
	}

}
}}}

|| _The concept of adaptors is one of the most important concepts in Eclipse platform. It is used to use one object in different contexts._ ||

==Selection service==
In the previous example, we saw that the viewer was registered as a selection provider (see line `getSite().setSelectionProvider(viewer);` in the class `TwitterMessageTimelineView`). There is also a way how to listen to selection events via registering an implementation of `ISelectionListener` with help of selection service (e.g., `getSite().getWorkbenchWindow().getSelectionService()`).

 

= Links =
 * Eclipse help: JFace - http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/jface.htm
 * Eclipse help: SWT - http://help.eclipse.org/helios/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/swt.htm 
 * SWT: Standard Widget Toolkit - http://www.eclipse.org/resources/resource.php?id=241 
 * SWT code snippets - http://www.eclipse.org/swt/snippets/
 * JFace code snippets - http://wiki.eclipse.org/index.php/JFaceSnippets
 * Lars Vogel: JFace tutorial - http://www.vogella.de/articles/EclipseJFaceTable/article.html
 * Eclipse tutorial: Creating Your Own Widgets using SWT - http://www.eclipse.org/articles/Article-Writing%20Your%20Own%20Widget/Writing%20Your%20Own%20Widget.htm
 * Eclipse tutorial: Understanding Layouts in SWT - http://www.eclipse.org/articles/article.php?file=Article-Understanding-Layouts/index.html
 * Eclipse workbench: Using the Selection Service - http://www.eclipse.org/articles/Article-WorkbenchSelections/article.html
 * Eclipse help: Core expressions - http://wiki.eclipse.org/Command_Core_Expressions
 * Eclipse tutorial: Take control over you properties - http://www.eclipse.org/articles/Article-Properties-View/properties-view.html
 * Eclipse tutorial: The Eclipse Tabbed Properties View - http://www.eclipse.org/articles/Article-Tabbed-Properties/tabbed_properties_view.html
 