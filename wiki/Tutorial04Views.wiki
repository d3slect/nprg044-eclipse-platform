#summary Eclipse views introduction
#labels Featured

= Introduction =
<wiki:toc max_depth="2" />

= Workbench UI =
Eclipse workbench provides a GUI model which is not connected to JFace. It provides workbench parts represented by _views_, and _editors_.
{{{
IAdaptable
 |- IWorkbenchPart
   |- IViewPart 
   |- IEditorPart
}}}

The class `IWorkbenchPart`:
 * method `void createPartControl(Composite parent)`
 * method `IWorkbenchPartSite getSite()` - _site_ is a primary interface between a workbench part and the workbench. For example, it is used for registering menus or global actions.
 * method `String getTitle()`
 * method `Image getTitleImage()`
 * method `void setFocus()` - Asks this part to take focus within the workbench. Parts must assign focus to one of the controls contained in the part's parent composite. It is called by workbench

  ||Note:_There are also interfaces `IWorkbenchPart2` and `IWorkbenchPart3`. They represent new version of `IWorkbenchPart`. This is common concept of introducing new version of interfaces in Eclipse_||

The class `IViewPart`:
 * `void init(IViewSite site)` - Initializes this view with the given view site. It is called by the workbench automatically during initialization of the part.

The class `IEditorPart`:
 * `void init(IEditorSite site, IEditorInput input)` - Initializes this editor with the given editor site and editor input (e.g., file, URI).It is automatically called by workbench.

== Views ==
A view is class implementing `IViewPart` interface. It shows a data with help of some [Tutorial03ViewsEditors#Viewers viewer]. It is beneficial to start with extending existing `ViewPart` class implementing basic infrastructure. 
 
Important points:
 * method `createControlPart()` - create a graphical viewer showed by a view. For example, table, tree, or hand-made graph visualizator. Any SWT code can be here.
   * calling method `viewer.setInput()` - setup viewer input 
   * calling method `viewer.setContentProvider()`
   * calling method `viewer.setLabelProvider()` 
   * registering actions hooks/menus - e.g., via calling `getSite().registerContextMenu(menuMgr, viewer);`

=== Example: `cz.cuni.mff.d3s.twitter.ui.views`===
  || Note: _Plug-in name follows common Eclipse naming convention - plug-in contributes into UI by providing new views hence its name contains `ui.views` part._||

  Goal: _Create a plugin providing a view showing message timeline for a given Twitter user._

  * import into a workspace plug-in `cz.cuni.mff.d3s.twitter.api`
  * create a new plug-in `cz.cuni.mff.d3s.twitter.ui.views`
  * configure `plugin.xml`:
    * add a dependency on plug-in `cz.cuni.mff.d3s.twitter.api`
    * add dependencies on plug-ins `org.eclipse.ui` and `org.eclipse.core.runtime`
    * define extension points:
      * `org.eclipse.ui.views`:
        * add a new category _Twitter Category_ 
          * category will be shown in menu _Window > Show Views > Others..._
        * add a new view
          * define ID, name, category (to Twitter category), icon
            * fastViewWidthRatio = 0.3 (one third of workbench width)
            * allowMultiple = true (we will allow showing timelines of various users)
          * define `class` attribute to `cz.cuni.mff.d3s.twitter.ui.views.TwitterMessageTimelineView`    
    * implements the class (inherits from the `ViewPart` class)
      * method `createPartControl(Composite parent)
        * create `GridLayout`, pass it to `parent.setLayout()`
{{{
GridLayout layout = new GridLayout(1, true);
parent.setLayout(layout);		
}}}
        * create `Text` control `searchBox` with flags `SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH`
         * setup layout data - `new GridData(GridData.FILL_HORIZONTAL)`
{{{
searchBox = new Text(parent, SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH);
searchBox.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
searchBox.setText("vtipy");
}}}
        * create `TableViewer` control `viewer` with flags `SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER`
         * setup layout data `new GridData(GridData.FILL_BOTH)`
           * you have to call `viewer.getControl()` to access underlying SWT control (`TableViewer` is JFace widget)
{{{
viewer = new TableViewer(parent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
viewer.getControl().setLayoutData(new GridData(GridData.FILL_BOTH));	
}}}
         * setup input to `viewer.setInput(getViewSite())`	
      * if you need lazy content resolving then put `SWT.VIRTUAL` into `viewer`'s flags. But, the content provider has to implement `ILazyContentProvider` instead of `IStructureContentProvider`
    * try to run in debug mode without configuring content provider
{{{
public class TwitterMessageTimelineView extends ViewPart {
	private static final String[] COLUMN_NAMES = {"#", "username", "message"};
	private static final int[] COLUMN_WIDTHS = {30, 100, 200};
	private TableViewer viewer;
	private Text searchBox;

	/**
	 * 
	 */
	public TwitterMessageTimelineView() {	
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.part.WorkbenchPart#createPartControl(org.eclipse.swt.widgets.Composite)
	 */
	@Override
	public void createPartControl(Composite parent) {
		GridLayout layout = new GridLayout(1, true);
		parent.setLayout(layout);		
		searchBox = new Text(parent, SWT.SINGLE | SWT.SEARCH | SWT.ICON_SEARCH);
		searchBox.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
		searchBox.setText("vtipy");		
				
		viewer = new TableViewer(parent, SWT.SINGLE | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER);
		createColumns(viewer);
		viewer.setContentProvider(new MessageTimelineContentProvider());
		viewer.setLabelProvider(new MessageTimelineLabelProvider());
		// the input for the content provider
		viewer.setInput(searchBox);		
		viewer.getControl().setLayoutData(new GridData(GridData.FILL_BOTH));

		// tuning of the underlying table		
		viewer.getTable().setLinesVisible(true);		
		viewer.getTable().setHeaderVisible(true);
		
		// make selection available to others
		getSite().setSelectionProvider(viewer);
	}
	
	private void createColumns(TableViewer tableViewer) {
		for (int i = 0; i < COLUMN_NAMES.length; i++) {
			TableViewerColumn tvColumn = new TableViewerColumn(tableViewer, SWT.NULL);
			TableColumn column = tvColumn.getColumn();
			column.setWidth(COLUMN_WIDTHS[i]);
			column.setText(COLUMN_NAMES[i]);
			// I can also here register separated cell providers via calling TableViewerColumn.setLabelProvider
			// - @see CellLabelProvider or StyledCellLabelProvider 			
		}		
	}

	/* (non-Javadoc)
	 * @see org.eclipse.ui.part.WorkbenchPart#setFocus()
	 */
	@Override
	public void setFocus() {
		this.searchBox.setFocus();
	}

}
}}}	

    * implements content provider `MessageTimelineContentProvider` inheriting from `IStructureContentProvider`
       * implements `inputChange` method
         * register/deregister listeners to input, refreshing of the viewer is not necessary, because it is done by underlying infrastructure
{{{
public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
  this.viewer = viewer;

  if (oldInput == newInput) 
	  return;

  if (oldInput instanceof Control) {
	  Control c = (Control) oldInput;
	  if (!c.isDisposed()) {
		  ((Control) oldInput).removeKeyListener(keyListener);
	  }
  }
  if (newInput instanceof Control) {
	  Control c = (Control) newInput;
	  if (!c.isDisposed()) {
		  ((Control) newInput).addKeyListener(keyListener);
	  }
  }
}
}}}
       * add key listern `keyListener`
{{{
private KeyListener keyListener = new KeyAdapter() {
        private String username;

	public void keyReleased(KeyEvent e) {
		if (e.keyCode == SWT.CR || e.keyCode == SWT.KEYPAD_CR) {
			if (e.widget instanceof Text) {
				String newUsername = ((Text) e.widget).getText();
				if (!newUsername.equals(username)) {
					username = newUsername;
					// run in UI thread
					e.display.asyncExec(new Runnable() {							
						@Override
						public void run() {
							// IMPORTANT it is required to check if the widget is not disposed
							if (!viewer.getControl().isDisposed()) {
								viewer.refresh();
							}
						}
					});
				}
			}
		}
	};
};
}}}
       * implements `getElements` method
        * parameter `inputElement` is an input element setup by calling `setInput` method of the viewer
{{{
public Object[] getElements(Object inputElement) {		
	  String username = getUsername(inputElement);
	  if (username == null || "".equals(username)) {
		  return EMPTY_CONTENT;			
	  } 
	  Twitter twitter = new TwitterFactory().getInstance();
  try {
      List<Status> statuses = twitter.getUserTimeline(username);
      if (!statuses.isEmpty()) {
	  return statuses.toArray();
      } else {
	  return EMPTY_CONTENT;
      }
  } catch (Exception e) {
	  return new String[] {e.getMessage()};
  }
}

private String getUsername(Object inputElement) {
	if (inputElement instanceof Text) {
		return ((Text) inputElement).getText();
	} else if (inputElement instanceof UserNode) {
		return ((UserNode) inputElement).getUser().getScreenName();			
	}
	
	return null;
}
}}}
       * in method `createPartControl` of the class `TwitterMessageTimelineView` setup `viewer.setInput(searchBox)` 
         * searchBox will serves as an input for content provider
         * it can be changed. The change invokes the method `inputChanged` of the content provider.
       * Note: _try to setup content provider for `viewer` control during debugging the application_
    * try to run without LabelProvider
{{{
public class MessageTimelineContentProvider implements
		IStructuredContentProvider {
	
	private final static String[] EMPTY_CONTENT = new String[] {"There is no message to show..."}; 
	
	private Viewer viewer;
	
	private KeyListener keyListener = new KeyAdapter() {
		private String username;
		public void keyReleased(KeyEvent e) {
			if (e.keyCode == SWT.CR || e.keyCode == SWT.KEYPAD_CR) {
				if (e.widget instanceof Text) {
					String newUsername = ((Text) e.widget).getText();
					if (!newUsername.equals(username)) {
						username = newUsername;
						// run in UI thread
						e.display.asyncExec(new Runnable() {							
							@Override
							public void run() {
								viewer.refresh();								
							}
						});
					}
				}
			}
		};
	};

	@Override
	public void dispose() {	
	}

	@Override
	public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
		this.viewer = viewer;
		
		if (oldInput instanceof Control) {
			Control c = (Control) oldInput;
			if (!c.isDisposed()) {
				((Control) oldInput).removeKeyListener(keyListener);
			}
		}
		if (newInput instanceof Control) {
			Control c = (Control) newInput;
			if (!c.isDisposed()) {
				((Control) newInput).addKeyListener(keyListener);
			}
		}
	}

	@Override
	public Object[] getElements(Object inputElement) {		
		String username = getUsername(inputElement);
		if (username == null || "".equals(username)) {
			return EMPTY_CONTENT;			
		} 
		Twitter twitter = new TwitterFactory().getInstance();
		try {
		    List<Status> statuses = twitter.getUserTimeline(username);
		    if (!statuses.isEmpty()) {
			return statuses.toArray();
		    } else {
			return EMPTY_CONTENT;
		    }
		} catch (Exception e) {
			return new String[] {e.getMessage()};
		}
	}
	
	private String getUsername(Object inputElement) {
		if (inputElement instanceof Text) {
			return ((Text) inputElement).getText();
		} 
		
		return null;
	}
}
}}}
    * implements `MessageTimelineLabelProvider` extending the class `LabelProvider` (implementing `ILabelProvider`) and implementing `ITableLabelProvider`.
     * it is neccessary to return the right text/image for each column
       * there is also way via the method `TableViewerColumn.setLabelProvider()` to configure separated label provider for each column.
     * for images you can use built-in images accessible via call `PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_ELEMENT);`      
{{{
public class MessageTimelineLabelProvider extends LabelProvider implements ITableLabelProvider {

	@Override
	public Image getColumnImage(Object element, int columnIndex) {
		if (element instanceof Status && columnIndex == 0) {
			return getImage(element);
		}
		
		return null;
	}

	@Override
	public String getColumnText(Object element, int columnIndex) {
		if (element instanceof Status) {
			Status status = (Status) element;
			
			switch (columnIndex) {
			case 0:
				return null;
			case 1:				
				return '@' + status.getUser().getScreenName();
			case 2:
				return status.getText();
			default:
				return null;
			}			
		}	
		
		return null;
	}
	
	@Override
	public Image getImage(Object element) {		
		return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_ELEMENT);
	}
}
}}}
     

== Actions in Views ==
===Context and Expressions===
We want to add delete command which will clear the timeline view.

First we have to define the context when the delete command will be applied. For this purpose, expresions can be used. Each expression defines a condition which has to be satisfied. The expression can be re-used in other definitions.
  * open `plugin.xml`
    * add a new dependency `org.eclipse.core.expressions`
  * add a new extension `org.eclipse.core.expressions.definitions`
   * define ID `cz.cuni.mff.d3s.nprg044.twitter.ui.view.inTimelineView`
     * add `with` sub-element with value `activePartId` (for more variables see [http://wiki.eclipse.org/Command_Core_Expressions Core Expressions Help])
       * add `equals` sub-element with value `cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (it is ID of defined MessageTimelineView)

Add a new handler for global delete command (with id `org.eclipse.ui.edit.delete`) which will be active if and only if the timeline view is focused:
  * open `plugin.xml`
  * add a new extension `org.eclipse.ui.handlers`
    * add a new handler:  
     * setup _commandId_ to `org.eclipse.ui.edit.delete`
     * add a new sub-element `activeWhen`
       * add a new `reference` sub-element and setup it to `cz.cuni.mff.d3s.nprg044.twitter.ui.view.inTimelineView`
    * add handler implementation:
      * look at a helper class `HandlerUtil`
{{{
public class CleanTimelineView extends AbstractHandler{

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		IWorkbenchPart part = HandlerUtil.getActivePart(event);
		if (part instanceof TwitterMessageTimelineView) {
			((TwitterMessageTimelineView) part).cleanTimeline();
		}
		return null;
	}

}
}}}
  * add a new method `cleanTimeline` into the class `TwitterMessageTimelineView`:
{{{
public void cleanTimeline() {
	searchBox.setText("");
	viewer.refresh();
}
}}}
  * try to run the example and observe behavior of delete command
 
===Toolbar===
Let's put the delete command into a toolbar of `TwitterMessageTimelineView` view:
  * open `plugin.xml`
  * add the extension `org.eclipse.ui.menus`
   * add a new _menuContribution_ 
     * setup _locationURI_ to `toolbar:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (toolbar:<view ID>)
     * add a sub-element _command_ referring `org.eclipse.ui.edit.delete` command

===Pop-up menu===
 * as above, but _locatioURI_ is `menu:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (menu:<view ID>)

===Context menu===
The context menu has to be register first to allow contribution via extension point 'org.eclipse.ui.menus'. The view can have multiple context menu registered. Default ID of the context  menu is the part ID.

 * Add a new method `createContextMenu` into the class `TwitterMessageTimelineView`
   * The method is called from the method `createPartControl`
{{{
private void createContextMenu() {
    MenuManager menuManager = new MenuManager("#PopupMenu");
    menuManager.setRemoveAllWhenShown(true);
    menuManager.addMenuListener(new IMenuListener() {
	    
	    @Override
	    public void menuAboutToShow(IMenuManager manager) {
		    fillContextMenu(manager);				
	    }
    });
    Menu menu = menuManager.createContextMenu(viewer.getControl());
    viewer.getControl().setMenu(menu);
    getSite().registerContextMenu(menuManager, viewer);
}
}}}
 * add method `fillContextMenu`
   * it is necessary to add a separator for additions - it is the place where new actions will be placed.
{{{
private void fillContextMenu(IMenuManager manager) {
	// this is required to allow contribution into the context menu
	manager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));				
}
}}}

 * add a _menuContribution_ like in cases above, but set _locationURI_ to `popup:cz.cuni.mff.d3s.nprg044.twitter.ui.view.MessageTimelineView` (for one context menu the locationURI has the form `popup:<view ID>`)
 
 * add a new _command_ definition `cz.cuni.mff.d3s.nprg044.twitter.ui.view.showMessageDetails` with default command handler which will show a _Property view_:
{{{
public class CleanTimelineView extends AbstractHandler{

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		IWorkbenchPart part = HandlerUtil.getActivePart(event);
		if (part instanceof TwitterMessageTimelineView) {
			((TwitterMessageTimelineView) part).cleanTimeline();
		}
		return null;
	}

}
}}}
  * add the command into context menu


== Property sheet ==
We want to select the message details in _Property View_. The message is represented by the object `Status`.

At first we have to provide a selection from the viewer. It is necessary to have the line 
{{{
getSite().setSelectionProvider(viewer);
}}} 
in the class `TwitterMessageTimelineView`.

Then we have to adapt `Status` to `IPropertySource` type which provides details about status (plugin `org.eclipse.ui.views` has to be in dependencies). There are two ways of adaptation:
  # the `Status` has to implement `IAdaptable` interface:
{{{
public Object getAdapter(Class adapter) {
  return IPropertySource.class.equals(adapter) ? return new TwitterStatusPropertySource(this) : null;
}
}}}
   * this is common solution if you can change the source code of `Status` class, however, in our case it is provided by third party library. But, there is another solution:
 # register an adapter factory for given type:
  * open `plugin.xml`
  * add a new extension `org.eclipse.core.runtime.adapters`
    * add a new factory:
      * _adaptableType_ = `twitter4j.Status` (what is adapted)
      * _class_ = `cz.cuni.mff.d3s.nprg044.twitter.ui.view.adapters.TwitterAdapterFactory` (adaptation factory)
      * add a new sub-element `adapter` (what is a target of adaptation)
        * _type_ = `org.eclipse.ui.views.properties.IPropertySource`

  * implements the factory `cz.cuni.mff.d3s.nprg044.twitter.ui.view.adapters.TwitterAdapterFactory`:
{{{
public class TwitterAdapterFactory implements IAdapterFactory {
	
	private static final Class[] SUPPORTED_ADAPTERS = { IPropertySource.class };

	@Override
	public Object getAdapter(Object adaptableObject, Class adapterType) {
		if  (IPropertySource.class.equals(adapterType)) {
			return new TwitterStatusPropertySource((Status) adaptableObject);
		}
		return null;
	}

	@Override
	public Class[] getAdapterList() {
		return SUPPORTED_ADAPTERS;
	}

}
}}}

   * and implement the class `TwitterStatusPropertySource`
{{{
public class TwitterStatusPropertySource implements IPropertySource {

	private static final String MSG_ID = "twitter.prop.msg";
	private static final String RETWEET_COUNT_ID = "twitter.prop.retweet.count";
	
	private Status status;	
	private IPropertyDescriptor[] propertyDescriptors;

	public TwitterStatusPropertySource(Status status) {
		this.status = status;
	}

	@Override
	public Object getEditableValue() {
		return null;
	}

	@Override
	public IPropertyDescriptor[] getPropertyDescriptors() {
		if (propertyDescriptors == null) {
			IPropertyDescriptor descMessage = new PropertyDescriptor(MSG_ID, "Message");
			IPropertyDescriptor retweetCount= new PropertyDescriptor(RETWEET_COUNT_ID, "Retweet count");
			propertyDescriptors = new IPropertyDescriptor[] { descMessage, retweetCount };
		}
		
		return propertyDescriptors;
	}

	@Override
	public Object getPropertyValue(Object id) {
		if (id.equals(MSG_ID)) {
			return status.getText();
		} else if (id.equals(RETWEET_COUNT_ID)) {
			return status.getRetweetCount();
		}
		
		return null;
	}

	@Override
	public boolean isPropertySet(Object id) {
		return false;
	}

	@Override
	public void resetPropertyValue(Object id) {
	}

	@Override
	public void setPropertyValue(Object id, Object value) {
	}

}
}}}

|| _The concept of adaptors is one of the most important concepts in Eclipse platform. It is used to use one object in different contexts._ ||

==Selection service==
In the previous example, we saw that the viewer was registered as a selection provider (see line `getSite().setSelectionProvider(viewer);` in the class `TwitterMessageTimelineView`). There is also a way how to listen to selection events via registering an implementation of `ISelectionListener` with help of selection service (e.g., `getSite().getWorkbenchWindow().getSelectionService()`).

 * create a new view providing a list of usernames
 * publish a viewer as a selection source
 * register a listener to a new view via _Selection service_
  * listener has to look at selection and repaint the viewer 

= Links =
 * SWT code snippets - http://www.eclipse.org/swt/snippets/
 * JFace code snippets - http://wiki.eclipse.org/index.php/JFaceSnippets
 * Lars Vogel: JFace tutorial - http://www.vogella.de/articles/EclipseJFaceTable/article.html
 * Eclipse workbench: Using the Selection Service - http://www.eclipse.org/articles/Article-WorkbenchSelections/article.html
 * Eclipse help: Core expressions - http://wiki.eclipse.org/Command_Core_Expressions
 * Eclipse tutorial: Take control over you properties - http://www.eclipse.org/articles/Article-Properties-View/properties-view.html
 * Eclipse tutorial: The Eclipse Tabbed Properties View - http://www.eclipse.org/articles/Article-Tabbed-Properties/tabbed_properties_view.html
 